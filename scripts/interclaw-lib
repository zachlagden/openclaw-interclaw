#!/usr/bin/env bash
# interclaw-lib — Shared library for all InterClaw scripts
# Source this file; do not execute directly.
#
# Provides: config loading, ULID generation, state management,
#           PGP helpers, logging, input validation.

set -euo pipefail

# ── Constants ──────────────────────────────────────────────────────
readonly INTERCLAW_DIR="${INTERCLAW_HOME:-${HOME}/.interclaw}"
readonly INTERCLAW_STATE_DIR="${INTERCLAW_DIR}/state"
readonly INTERCLAW_CONV_DIR="${INTERCLAW_STATE_DIR}/conversations"
readonly INTERCLAW_ACKS_DIR="${INTERCLAW_STATE_DIR}/pending_acks"
readonly INTERCLAW_KEYS_DIR="${INTERCLAW_DIR}/trusted_keys"
readonly INTERCLAW_LOG_DIR="${INTERCLAW_DIR}/logs"
readonly INTERCLAW_SENT_ARCHIVE="${INTERCLAW_DIR}/sent_archive"
readonly INTERCLAW_CONFIG="${INTERCLAW_DIR}/config.env"
readonly INTERCLAW_GLOBAL_SEQ_FILE="${INTERCLAW_STATE_DIR}/global_seq"
readonly INTERCLAW_THREADS_JSON="${INTERCLAW_STATE_DIR}/threads.json"
readonly INTERCLAW_PENDING_HS_DIR="${INTERCLAW_STATE_DIR}/pending_handshakes"
readonly INTERCLAW_LOG_FILE="${INTERCLAW_LOG_DIR}/interclaw.log"

readonly CROCKFORD_ALPHABET="0123456789ABCDEFGHJKMNPQRSTVWXYZ"

# Valid tags
readonly VALID_TAGS="RELAY COORD INTEL ENCRYPTED SELFIMPROVE ACK HANDSHAKE RECV PING DIGEST MULTI MISSING"

# ── Logging ────────────────────────────────────────────────────────
_log_level_num() {
    case "${1^^}" in
        DEBUG) echo 0 ;;
        INFO)  echo 1 ;;
        WARN)  echo 2 ;;
        ERROR) echo 3 ;;
        *)     echo 1 ;;
    esac
}

log() {
    local level="$1"; shift
    local configured_level="${INTERCLAW_LOG_LEVEL:-INFO}"
    local level_num; level_num=$(_log_level_num "$level")
    local configured_num; configured_num=$(_log_level_num "$configured_level")

    if (( level_num >= configured_num )); then
        local ts; ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        local msg="[${ts}] [${level}] $*"
        echo "$msg" >> "${INTERCLAW_LOG_FILE}" 2>/dev/null || true
        if [[ "$level" == "ERROR" ]]; then
            echo "ERROR: $*" >&2
        elif [[ "${INTERCLAW_VERBOSE:-false}" == "true" ]]; then
            echo "$msg" >&2
        fi
    fi
}

die() {
    log ERROR "$@"
    echo "FATAL: $*" >&2
    exit 1
}

# ── Directory Initialization ──────────────────────────────────────
ensure_dirs() {
    mkdir -p "${INTERCLAW_STATE_DIR}" \
             "${INTERCLAW_CONV_DIR}" \
             "${INTERCLAW_ACKS_DIR}" \
             "${INTERCLAW_PENDING_HS_DIR}" \
             "${INTERCLAW_KEYS_DIR}" \
             "${INTERCLAW_LOG_DIR}" \
             "${INTERCLAW_SENT_ARCHIVE}"

    # Restrict permissions on sensitive dirs
    chmod 700 "${INTERCLAW_DIR}" 2>/dev/null || true
    chmod 700 "${INTERCLAW_KEYS_DIR}" 2>/dev/null || true

    # Initialize global seq if missing
    if [[ ! -f "${INTERCLAW_GLOBAL_SEQ_FILE}" ]]; then
        echo "0" > "${INTERCLAW_GLOBAL_SEQ_FILE}"
    fi
}

# ── Config Loading ────────────────────────────────────────────────
# Usage: load_config [--require-imap]
# By default, only core vars (email, SMTP, PGP) are required.
# Pass --require-imap to also require IMAP vars (for --poll/--once modes).
load_config() {
    local require_imap=false
    if [[ "${1:-}" == "--require-imap" ]]; then
        require_imap=true
    fi

    if [[ ! -f "${INTERCLAW_CONFIG}" ]]; then
        die "Config not found at ${INTERCLAW_CONFIG}. Run: interclaw-config init"
    fi

    # Source config (only export known variables, not arbitrary code)
    local line key val
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments and blank lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        # Only process KEY=VALUE lines with known prefixes
        if [[ "$line" =~ ^(INTERCLAW_|PGP_|HIMALAYA_)[A-Z_]+=.* ]]; then
            key="${line%%=*}"
            val="${line#*=}"
            # Strip surrounding quotes
            val="${val#\"}"
            val="${val%\"}"
            val="${val#\'}"
            val="${val%\'}"
            # Expand simple ${HOME} and ${INTERCLAW_EMAIL} references
            val="${val//\$\{HOME\}/${HOME}}"
            val="${val//\$\{INTERCLAW_EMAIL\}/${INTERCLAW_EMAIL:-}}"
            export "$key=$val"
        fi
    done < "${INTERCLAW_CONFIG}"

    # Validate required vars — core set always required
    local required_vars=(
        INTERCLAW_EMAIL
        INTERCLAW_SMTP_HOST
        INTERCLAW_SMTP_PORT
        PGP_PRIVATE_KEY_ID
    )

    # IMAP vars only required when explicitly requested (poll/once modes)
    if [[ "$require_imap" == "true" ]]; then
        required_vars+=(
            INTERCLAW_IMAP_HOST
            INTERCLAW_IMAP_PORT
        )
    fi

    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            die "Required config variable ${var} is not set in ${INTERCLAW_CONFIG}"
        fi
    done

    log DEBUG "Config loaded from ${INTERCLAW_CONFIG}"
}

# ── ULID Generation ───────────────────────────────────────────────
# Generates a 26-character ULID (Crockford Base32 encoded)
# Format: 10 chars timestamp (ms) + 16 chars random
generate_ulid() {
    local ts_ms
    # Get millisecond timestamp
    if [[ -r /proc/uptime ]] && command -v date &>/dev/null; then
        ts_ms=$(( $(date +%s%N) / 1000000 ))
    else
        ts_ms=$(( $(date +%s) * 1000 ))
    fi

    # Encode 48-bit timestamp as 10 Crockford Base32 characters
    local t=$ts_ms
    local ts_encoded=""
    local i
    for i in $(seq 1 10); do
        ts_encoded="${CROCKFORD_ALPHABET:$((t & 31)):1}${ts_encoded}"
        t=$((t >> 5))
    done

    # Encode 80 bits of randomness as 16 Crockford Base32 characters.
    # Read exactly 10 bytes (80 bits) and extract 5-bit groups across
    # byte boundaries for uniform distribution (no modular bias).
    local rand_encoded=""
    local -a rbytes
    local b
    while IFS= read -r b; do
        [[ -z "$b" ]] && continue
        rbytes+=("$b")
    done < <(od -An -tu1 -N10 /dev/urandom | tr -s ' ' '\n' | sed '/^$/d')

    # Pack bytes into a bit buffer and extract 5-bit chunks
    local bit_buffer=0
    local bits_in_buffer=0
    local byte_idx=0
    local chars_out=0

    while (( chars_out < 16 )); do
        # Load more bits if needed
        while (( bits_in_buffer < 5 && byte_idx < ${#rbytes[@]} )); do
            bit_buffer=$(( (bit_buffer << 8) | rbytes[byte_idx] ))
            bits_in_buffer=$(( bits_in_buffer + 8 ))
            byte_idx=$(( byte_idx + 1 ))
        done

        # Extract top 5 bits
        bits_in_buffer=$(( bits_in_buffer - 5 ))
        local idx=$(( (bit_buffer >> bits_in_buffer) & 31 ))
        rand_encoded="${rand_encoded}${CROCKFORD_ALPHABET:$idx:1}"
        chars_out=$(( chars_out + 1 ))
    done

    echo "${ts_encoded}${rand_encoded}"
}

# ── Global Sequence ───────────────────────────────────────────────
# Returns the next GlobalSeq and increments the counter atomically.
# Uses flock to prevent TOCTOU races between concurrent processes.
next_global_seq() {
    local next
    next=$(
        flock -x 200
        local current
        current=$(cat "${INTERCLAW_GLOBAL_SEQ_FILE}" 2>/dev/null || echo "0")
        local n=$(( current + 1 ))
        echo "${n}" > "${INTERCLAW_GLOBAL_SEQ_FILE}"
        echo "${n}"
    ) 200>"${INTERCLAW_GLOBAL_SEQ_FILE}.lock"
    printf "D-%03d" "${next}"
}

get_global_seq() {
    local current
    current=$(cat "${INTERCLAW_GLOBAL_SEQ_FILE}" 2>/dev/null || echo "0")
    printf "D-%03d" "${current}"
}

# ── Conversation State ────────────────────────────────────────────
# Create a new conversation, returns the ConvID
create_conversation() {
    local topic="$1"
    local tag="$2"
    local participants="$3"  # comma-separated

    local conv_id; conv_id=$(generate_ulid)
    local conv_dir="${INTERCLAW_CONV_DIR}/${conv_id}"

    mkdir -p "${conv_dir}/sent" "${conv_dir}/received"

    local ts; ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat > "${conv_dir}/meta" <<EOF
topic=${topic}
tag=${tag}
participants=${participants}
created_at=${ts}
last_activity=${ts}
EOF
    echo "0" > "${conv_dir}/conv_seq"

    log INFO "Created conversation ${conv_id} topic=${topic} tag=${tag}"
    echo "${conv_id}"
}

# Increment ConvSeq for a conversation, returns the new value.
# Uses flock to prevent TOCTOU races between concurrent processes.
next_conv_seq() {
    local conv_id="$1"
    local conv_dir="${INTERCLAW_CONV_DIR}/${conv_id}"

    if [[ ! -d "${conv_dir}" ]]; then
        die "Conversation ${conv_id} does not exist"
    fi

    local seq_file="${conv_dir}/conv_seq"
    local next
    next=$(
        flock -x 200
        local current
        current=$(cat "${seq_file}" 2>/dev/null || echo "0")
        local n=$(( current + 1 ))
        echo "${n}" > "${seq_file}"
        echo "${n}"
    ) 200>"${seq_file}.lock"

    # Update last_activity
    local ts; ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    sed -i "s/^last_activity=.*/last_activity=${ts}/" "${conv_dir}/meta" 2>/dev/null || true

    printf "%03d" "${next}"
}

get_conv_seq() {
    local conv_id="$1"
    local conv_dir="${INTERCLAW_CONV_DIR}/${conv_id}"
    local current
    current=$(cat "${conv_dir}/conv_seq" 2>/dev/null || echo "0")
    printf "%03d" "${current}"
}

# Read conversation metadata
get_conv_meta() {
    local conv_id="$1"
    local field="$2"
    local conv_dir="${INTERCLAW_CONV_DIR}/${conv_id}"
    local meta_file="${conv_dir}/meta"

    if [[ ! -f "${meta_file}" ]]; then
        echo ""
        return
    fi
    grep "^${field}=" "${meta_file}" 2>/dev/null | head -1 | cut -d= -f2-
}

# Find conversation by topic (returns first match)
find_conversation() {
    local topic="$1"
    local participants="$2"  # optional

    local conv_dir
    for conv_dir in "${INTERCLAW_CONV_DIR}"/*/; do
        [[ -d "$conv_dir" ]] || continue
        local conv_id; conv_id=$(basename "$conv_dir")
        local meta_topic; meta_topic=$(get_conv_meta "$conv_id" "topic")
        if [[ "$meta_topic" == "$topic" ]]; then
            if [[ -z "$participants" ]]; then
                echo "$conv_id"
                return 0
            fi
            local meta_parts; meta_parts=$(get_conv_meta "$conv_id" "participants")
            if [[ "$meta_parts" == "$participants" ]]; then
                echo "$conv_id"
                return 0
            fi
        fi
    done
    return 1
}

# List all conversations
list_conversations() {
    local conv_dir
    for conv_dir in "${INTERCLAW_CONV_DIR}"/*/; do
        [[ -d "$conv_dir" ]] || continue
        local conv_id; conv_id=$(basename "$conv_dir")
        local topic; topic=$(get_conv_meta "$conv_id" "topic")
        local tag; tag=$(get_conv_meta "$conv_id" "tag")
        local participants; participants=$(get_conv_meta "$conv_id" "participants")
        local seq; seq=$(get_conv_seq "$conv_id")
        local created; created=$(get_conv_meta "$conv_id" "created_at")
        local activity; activity=$(get_conv_meta "$conv_id" "last_activity")
        echo "${conv_id}|${topic}|${tag}|${participants}|${seq}|${created}|${activity}"
    done
}

# ── Pending ACKs ──────────────────────────────────────────────────
add_pending_ack() {
    local conv_id="$1"
    local conv_seq="$2"
    local recipient="$3"

    local ack_file="${INTERCLAW_ACKS_DIR}/${conv_id}:${conv_seq}"
    local ts; ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    echo "recipient=${recipient}" > "${ack_file}"
    echo "sent_at=${ts}" >> "${ack_file}"
    log DEBUG "Added pending ACK for ${conv_id}:${conv_seq} → ${recipient}"
}

resolve_pending_ack() {
    local conv_id="$1"
    local conv_seq="$2"

    local ack_file="${INTERCLAW_ACKS_DIR}/${conv_id}:${conv_seq}"
    if [[ -f "${ack_file}" ]]; then
        rm -f "${ack_file}"
        log INFO "Resolved ACK for ${conv_id}:${conv_seq}"
    fi
}

list_pending_acks() {
    local ack_file
    for ack_file in "${INTERCLAW_ACKS_DIR}"/*; do
        [[ -f "$ack_file" ]] || continue
        local key; key=$(basename "$ack_file")
        local recipient; recipient=$(grep "^recipient=" "$ack_file" 2>/dev/null | cut -d= -f2-)
        local sent_at; sent_at=$(grep "^sent_at=" "$ack_file" 2>/dev/null | cut -d= -f2-)
        echo "${key}|${recipient}|${sent_at}"
    done
}

# ── Sent Archive ──────────────────────────────────────────────────
archive_sent_message() {
    local global_seq="$1"
    local conv_id="$2"
    local conv_seq="$3"
    local full_message="$4"
    local tag="${5:-UNKNOWN}"

    echo "$full_message" > "${INTERCLAW_SENT_ARCHIVE}/${global_seq}.msg"

    # Also archive in conversation directory
    local conv_sent="${INTERCLAW_CONV_DIR}/${conv_id}/sent"
    mkdir -p "$conv_sent"
    echo "$full_message" > "${conv_sent}/${conv_seq}.msg"

    # Store tag metadata for retransmit tag preservation
    echo "$tag" > "${conv_sent}/${conv_seq}.tag"

    log DEBUG "Archived sent message ${global_seq} → ${conv_id}:${conv_seq} [${tag}]"
}

# Retrieve a sent message for retransmit
get_archived_message() {
    local conv_id="$1"
    local conv_seq="$2"

    local msg_file="${INTERCLAW_CONV_DIR}/${conv_id}/sent/${conv_seq}.msg"
    if [[ -f "$msg_file" ]]; then
        cat "$msg_file"
        return 0
    fi
    return 1
}

# ── Received Archive ──────────────────────────────────────────────
archive_received_message() {
    local conv_id="$1"
    local conv_seq="$2"
    local sender="$3"
    local content="$4"

    local recv_dir="${INTERCLAW_CONV_DIR}/${conv_id}/received"
    mkdir -p "$recv_dir"

    local ts; ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    {
        echo "sender=${sender}"
        echo "received_at=${ts}"
        echo "---"
        echo "$content"
    } > "${recv_dir}/${conv_seq}.msg"

    log DEBUG "Archived received message ${conv_id}:${conv_seq} from ${sender}"
}

# Check if a ConvSeq was already received
is_duplicate() {
    local conv_id="$1"
    local conv_seq="$2"
    [[ -f "${INTERCLAW_CONV_DIR}/${conv_id}/received/${conv_seq}.msg" ]]
}

# ── PGP Helpers ───────────────────────────────────────────────────
pgp_sign() {
    local message="$1"
    local key_id="${PGP_PRIVATE_KEY_ID}"

    if [[ -n "${PGP_PASSPHRASE:-}" ]]; then
        # Use --passphrase-fd to avoid exposing passphrase in /proc/pid/cmdline
        echo "$message" | gpg --batch --yes --pinentry-mode loopback \
            --passphrase-fd 3 \
            --local-user "${key_id}" \
            --clearsign 3< <(printf '%s' "$PGP_PASSPHRASE") 2>/dev/null
    else
        echo "$message" | gpg --batch --yes \
            --local-user "${key_id}" \
            --clearsign 2>/dev/null
    fi
}

pgp_sign_and_encrypt() {
    # Usage: pgp_sign_and_encrypt "message" "recipient1" ["recipient2" ...]
    local message="$1"; shift
    local key_id="${PGP_PRIVATE_KEY_ID}"

    # Build --recipient flags for all recipients
    local -a recipient_flags=()
    local r
    for r in "$@"; do
        recipient_flags+=(--recipient "$r")
    done

    if [[ ${#recipient_flags[@]} -eq 0 ]]; then
        log ERROR "pgp_sign_and_encrypt: no recipients specified"
        return 1
    fi

    if [[ -n "${PGP_PASSPHRASE:-}" ]]; then
        # Use --passphrase-fd to avoid exposing passphrase in /proc/pid/cmdline
        echo "$message" | gpg --batch --yes --pinentry-mode loopback \
            --passphrase-fd 3 \
            --local-user "${key_id}" \
            --sign --encrypt \
            "${recipient_flags[@]}" \
            --armor 3< <(printf '%s' "$PGP_PASSPHRASE") 2>/dev/null
    else
        echo "$message" | gpg --batch --yes \
            --local-user "${key_id}" \
            --sign --encrypt \
            "${recipient_flags[@]}" \
            --armor 2>/dev/null
    fi
}

pgp_verify() {
    local signed_message="$1"
    local result
    result=$(echo "$signed_message" | gpg --batch --verify 2>&1) || true
    echo "$result"
}

pgp_verify_strict() {
    # Returns 0 if signature is valid and from a trusted fingerprint
    local signed_message="$1"
    local verify_output
    verify_output=$(echo "$signed_message" | gpg --batch --status-fd 1 --verify 2>/dev/null) || true

    # Extract fingerprint from VALIDSIG line
    local fingerprint
    fingerprint=$(echo "$verify_output" | grep "^\[GNUPG:\] VALIDSIG" | awk '{print $3}')

    if [[ -z "$fingerprint" ]]; then
        log ERROR "PGP verification failed: no valid signature"
        return 1
    fi

    # Check against trusted fingerprints
    if ! is_trusted_fingerprint "$fingerprint"; then
        log ERROR "PGP verification failed: fingerprint ${fingerprint} not trusted"
        return 1
    fi

    echo "$fingerprint"
    return 0
}

pgp_decrypt() {
    # Decrypts a PGP message. For signed+encrypted messages, gpg verifies
    # the signature during decryption. The signature fingerprint is written
    # to DECRYPT_SIG_FINGERPRINT (empty if no embedded signature).
    local encrypted_message="$1"
    DECRYPT_SIG_FINGERPRINT=""

    local status_file
    status_file=$(mktemp)
    local plaintext

    if [[ -n "${PGP_PASSPHRASE:-}" ]]; then
        # Use --passphrase-fd to avoid exposing passphrase in /proc/pid/cmdline.
        # fd 4 for passphrase, fd 3 for status output.
        plaintext=$(echo "$encrypted_message" | gpg --batch --yes --pinentry-mode loopback \
            --passphrase-fd 4 \
            --status-fd 3 \
            --decrypt 3>"$status_file" 4< <(printf '%s' "$PGP_PASSPHRASE") 2>/dev/null)
    else
        plaintext=$(echo "$encrypted_message" | gpg --batch --yes \
            --status-fd 3 \
            --decrypt 3>"$status_file" 2>/dev/null)
    fi

    local rc=$?

    # Extract signature fingerprint from gpg status output
    DECRYPT_SIG_FINGERPRINT=$(grep "^\[GNUPG:\] VALIDSIG" "$status_file" 2>/dev/null | awk '{print $3}')
    rm -f "$status_file"

    if [[ $rc -ne 0 ]]; then
        return 1
    fi

    echo "$plaintext"
}

pgp_export_pubkey() {
    local key_id="${PGP_PRIVATE_KEY_ID}"
    gpg --armor --export "${key_id}" 2>/dev/null
}

pgp_import_key() {
    local key_data="$1"
    echo "$key_data" | gpg --batch --import 2>&1
}

pgp_get_fingerprint() {
    local key_id="$1"
    gpg --batch --with-colons --fingerprint "${key_id}" 2>/dev/null \
        | grep "^fpr:" | head -1 | cut -d: -f10
}

# ── Trust Management ──────────────────────────────────────────────
is_trusted_fingerprint() {
    local fp="$1"
    local trusted="${INTERCLAW_TRUSTED_FINGERPRINTS:-}"

    # Check comma-separated list
    local IFS=','
    local trusted_fp
    for trusted_fp in $trusted; do
        # Trim whitespace
        trusted_fp="${trusted_fp## }"
        trusted_fp="${trusted_fp%% }"
        if [[ "$trusted_fp" == "$fp" ]]; then
            return 0
        fi
    done

    # Also check individual key files
    if [[ -f "${INTERCLAW_KEYS_DIR}/${fp}.asc" ]]; then
        return 0
    fi

    return 1
}

add_trusted_fingerprint() {
    local fp="$1"
    local current="${INTERCLAW_TRUSTED_FINGERPRINTS:-}"

    if is_trusted_fingerprint "$fp"; then
        log INFO "Fingerprint ${fp} already trusted"
        return 0
    fi

    if [[ -z "$current" ]]; then
        new_val="$fp"
    else
        new_val="${current},${fp}"
    fi

    # Update config file
    if grep -q "^INTERCLAW_TRUSTED_FINGERPRINTS=" "${INTERCLAW_CONFIG}" 2>/dev/null; then
        sed -i "s|^INTERCLAW_TRUSTED_FINGERPRINTS=.*|INTERCLAW_TRUSTED_FINGERPRINTS=\"${new_val}\"|" "${INTERCLAW_CONFIG}"
    else
        echo "INTERCLAW_TRUSTED_FINGERPRINTS=\"${new_val}\"" >> "${INTERCLAW_CONFIG}"
    fi
    export INTERCLAW_TRUSTED_FINGERPRINTS="$new_val"
    log INFO "Added trusted fingerprint: ${fp}"
}

# ── Input Validation ──────────────────────────────────────────────
validate_tag() {
    local tag="$1"
    local valid
    for valid in $VALID_TAGS; do
        if [[ "$tag" == "$valid" ]]; then
            return 0
        fi
    done
    return 1
}

validate_email() {
    local email="$1"
    if [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        return 0
    fi
    return 1
}

validate_conv_id() {
    local id="$1"
    if [[ "$id" =~ ^[0-9A-Z]{26}$ ]]; then
        return 0
    fi
    return 1
}

validate_global_seq() {
    local seq="$1"
    if [[ "$seq" =~ ^D-[0-9]{3,}$ ]]; then
        return 0
    fi
    return 1
}

validate_conv_seq() {
    local seq="$1"
    if [[ "$seq" =~ ^[0-9]{3,}$ ]]; then
        return 0
    fi
    return 1
}

# ── Timestamp Validation ──────────────────────────────────────────
validate_timestamp() {
    local ts="$1"
    if [[ "$ts" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$ ]]; then
        return 0
    fi
    return 1
}

validate_timestamp_age() {
    local ts="$1"
    local max_age="${2:-86400}"
    local msg_epoch
    msg_epoch=$(date -u -d "$ts" +%s 2>/dev/null) || \
        msg_epoch=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$ts" +%s 2>/dev/null) || return 1
    local now_epoch; now_epoch=$(date +%s)
    local age=$(( now_epoch - msg_epoch ))
    # Allow 5 min future clock skew
    if (( age < -300 )); then return 1; fi
    if (( age > max_age )); then return 1; fi
    return 0
}

# Sanitize body text: strip HTML tags, remove dangerous patterns
sanitize_body() {
    local text="$1"
    # Strip HTML tags
    text=$(echo "$text" | sed 's/<[^>]*>//g')
    # Remove null bytes
    text=$(echo "$text" | tr -d '\0')
    # Strip ANSI escape sequences (prevents terminal injection)
    text=$(echo "$text" | sed $'s/\x1b\\[[0-9;]*[a-zA-Z]//g')
    echo "$text"
}

# ── Himalaya Helpers ──────────────────────────────────────────────
himalaya_send() {
    local to="$1"
    local subject="$2"
    local body="$3"

    echo "$body" | himalaya send --to "$to" --subject "$subject" 2>&1
}

himalaya_list_new() {
    # List unread messages, return JSON-like output
    himalaya list --folder INBOX --query "unseen" 2>/dev/null || true
}

himalaya_read() {
    local msg_id="$1"
    himalaya read --plain "$msg_id" 2>/dev/null
}

himalaya_move() {
    local msg_id="$1"
    local folder="$2"
    himalaya move "$msg_id" "$folder" 2>/dev/null || true
}

# ── Threads JSON Generation ──────────────────────────────────────
generate_threads_json() {
    local global_seq
    global_seq=$(cat "${INTERCLAW_GLOBAL_SEQ_FILE}" 2>/dev/null || echo "0")
    local agent_id="${INTERCLAW_AGENT_ID:-unknown}"

    # Start JSON
    local json="{"
    json+="\"agent_id\":\"$(json_escape "$agent_id")\","
    json+="\"global_seq\":${global_seq},"
    json+="\"conversations\":{"

    local first_conv=true
    local conv_dir
    for conv_dir in "${INTERCLAW_CONV_DIR}"/*/; do
        [[ -d "$conv_dir" ]] || continue
        local conv_id; conv_id=$(basename "$conv_dir")
        local topic; topic=$(get_conv_meta "$conv_id" "topic")
        local tag; tag=$(get_conv_meta "$conv_id" "tag")
        local participants; participants=$(get_conv_meta "$conv_id" "participants")
        local seq; seq=$(cat "${conv_dir}/conv_seq" 2>/dev/null || echo "0")
        local created; created=$(get_conv_meta "$conv_id" "created_at")
        local activity; activity=$(get_conv_meta "$conv_id" "last_activity")

        if [[ "$first_conv" != "true" ]]; then
            json+=","
        fi
        first_conv=false

        # Build participants array
        local parts_json="["
        local first_part=true
        local IFS=','
        local p
        for p in $participants; do
            p="${p## }"
            p="${p%% }"
            if [[ "$first_part" != "true" ]]; then
                parts_json+=","
            fi
            first_part=false
            parts_json+="\"$(json_escape "$p")\""
        done
        parts_json+="]"

        json+="\"${conv_id}\":{"
        json+="\"topic\":\"$(json_escape "$topic")\","
        json+="\"tag\":\"$(json_escape "$tag")\","
        json+="\"participants\":${parts_json},"
        json+="\"conv_seq\":${seq},"
        json+="\"created_at\":\"$(json_escape "$created")\","
        json+="\"last_activity\":\"$(json_escape "$activity")\""
        json+="}"
    done

    json+="},"

    # Pending ACKs
    json+="\"pending_acks\":{"
    local first_ack=true
    local ack_file
    for ack_file in "${INTERCLAW_ACKS_DIR}"/*; do
        [[ -f "$ack_file" ]] || continue
        local key; key=$(basename "$ack_file")
        local recipient; recipient=$(grep "^recipient=" "$ack_file" 2>/dev/null | cut -d= -f2-)
        local sent_at; sent_at=$(grep "^sent_at=" "$ack_file" 2>/dev/null | cut -d= -f2-)

        if [[ "$first_ack" != "true" ]]; then
            json+=","
        fi
        first_ack=false

        json+="\"${key}\":{\"recipient\":\"$(json_escape "$recipient")\",\"sent_at\":\"$(json_escape "$sent_at")\"}"
    done

    json+="}}"

    echo "$json" > "${INTERCLAW_THREADS_JSON}"
    log DEBUG "Generated threads.json"
}

# ── Parse InterClaw Headers from Message Body ────────────────────
# Sets global variables: PARSED_GLOBAL_SEQ, PARSED_CONV_ID, etc.
parse_interclaw_headers() {
    local body="$1"

    PARSED_GLOBAL_SEQ=""
    PARSED_CONV_ID=""
    PARSED_CONV_SEQ=""
    PARSED_REF=""
    PARSED_TIMESTAMP=""
    PARSED_AGENT_ID=""
    PARSED_AGENT_SECRET=""
    PARSED_BODY=""

    local in_headers=true
    local line
    while IFS= read -r line; do
        if $in_headers; then
            case "$line" in
                GlobalSeq:*)  PARSED_GLOBAL_SEQ=$(echo "$line" | sed 's/^GlobalSeq:[[:space:]]*//' | sed 's/[[:space:]]*#.*//') ;;
                ConvID:*)     PARSED_CONV_ID=$(echo "$line" | sed 's/^ConvID:[[:space:]]*//' | sed 's/[[:space:]]*#.*//') ;;
                ConvSeq:*)    PARSED_CONV_SEQ=$(echo "$line" | sed 's/^ConvSeq:[[:space:]]*//' | sed 's/[[:space:]]*#.*//') ;;
                Ref:*)        PARSED_REF=$(echo "$line" | sed 's/^Ref:[[:space:]]*//' | sed 's/[[:space:]]*#.*//') ;;
                Timestamp:*)  PARSED_TIMESTAMP=$(echo "$line" | sed 's/^Timestamp:[[:space:]]*//' | sed 's/[[:space:]]*#.*//') ;;
                X-Agent-ID:*) PARSED_AGENT_ID=$(echo "$line" | sed 's/^X-Agent-ID:[[:space:]]*//' | sed 's/[[:space:]]*#.*//') ;;
                X-Agent-Secret:*) PARSED_AGENT_SECRET=$(echo "$line" | sed 's/^X-Agent-Secret:[[:space:]]*//' | sed 's/[[:space:]]*#.*//') ;;
                "")           in_headers=false ;;
                *)
                    # Non-header line while still in header section = start of body
                    if ! echo "$line" | grep -qE '^[A-Za-z][A-Za-z0-9_-]*:'; then
                        in_headers=false
                        PARSED_BODY="${line}"
                    fi
                    ;;
            esac
        else
            if [[ -z "$PARSED_BODY" ]]; then
                PARSED_BODY="$line"
            else
                PARSED_BODY="${PARSED_BODY}
${line}"
            fi
        fi
    done <<< "$body"
}

# ── Rate Limiting ─────────────────────────────────────────────────
# Uses flock to prevent concurrent processes from reading/writing
# the window file simultaneously, which could allow more messages
# than the configured limit.
check_rate_limit() {
    local sender="$1"
    local limit="${2:-60}"
    local window_file="${INTERCLAW_STATE_DIR}/.ratelimit_${sender//[^a-zA-Z0-9]/_}"

    local result
    result=$(
        flock -x 200

        local now; now=$(date +%s)
        local window_start=$(( now - 3600 ))

        # Read and filter timestamps within the last hour
        local count=0
        local new_content=""
        if [[ -f "$window_file" ]]; then
            while IFS= read -r ts; do
                [[ -z "$ts" ]] && continue
                if (( ts > window_start )); then
                    new_content+="${ts}"$'\n'
                    count=$(( count + 1 ))
                fi
            done < "$window_file"
        fi

        if (( count >= limit )); then
            # Write back filtered entries, then signal rejection
            printf '%s' "$new_content" > "$window_file"
            echo "REJECTED"
        else
            # Append current timestamp and write back
            new_content+="${now}"$'\n'
            printf '%s' "$new_content" > "$window_file"
            echo "OK"
        fi
    ) 200>"${window_file}.lock"

    if [[ "$result" == "REJECTED" ]]; then
        log WARN "Rate limit exceeded for ${sender}: limit=${limit} per hour"
        return 1
    fi
    return 0
}

# ── JSON Helpers ──────────────────────────────────────────────────
json_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    s="${s//$'\n'/\\n}"
    s="${s//$'\r'/\\r}"
    s="${s//$'\t'/\\t}"
    echo "$s"
}

# ── Utility ───────────────────────────────────────────────────────
# Check that required binaries are available
check_dependencies() {
    local bins=("gpg" "himalaya")
    local missing=()
    for bin in "${bins[@]}"; do
        if ! command -v "$bin" &>/dev/null; then
            missing+=("$bin")
        fi
    done
    if (( ${#missing[@]} > 0 )); then
        die "Missing required binaries: ${missing[*]}. Run: interclaw-bootstrap"
    fi
}

# Timestamp helper
now_utc() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# Safe temp file
safe_tmpfile() {
    mktemp "${TMPDIR:-/tmp}/interclaw.XXXXXXXXXX"
}

# ── Pending Handshake Queue ───────────────────────────────────────
# Save a pending handshake so it can be retried or auto-completed
save_pending_handshake() {
    local peer="$1"
    local retries_remaining="${2:-3}"
    local retry_delay="${3:-300}"
    local expected_fp="${4:-}"

    local safe_peer="${peer//[^a-zA-Z0-9@._-]/_}"
    local hs_dir="${INTERCLAW_PENDING_HS_DIR}/${safe_peer}"
    mkdir -p "$hs_dir"

    echo "$retries_remaining" > "${hs_dir}/retries_remaining"
    echo "$retry_delay" > "${hs_dir}/retry_delay"
    echo "$expected_fp" > "${hs_dir}/fingerprint"
    echo "$(now_utc)" > "${hs_dir}/initiated_at"

    local next_retry; next_retry=$(( $(date +%s) + retry_delay ))
    echo "$next_retry" > "${hs_dir}/next_retry_at"

    log INFO "Saved pending handshake for ${peer} (retries=${retries_remaining}, delay=${retry_delay}s)"
}

# Get pending handshake info. Returns 0 if exists, 1 if not.
get_pending_handshake() {
    local peer="$1"
    local safe_peer="${peer//[^a-zA-Z0-9@._-]/_}"
    local hs_dir="${INTERCLAW_PENDING_HS_DIR}/${safe_peer}"

    if [[ ! -d "$hs_dir" ]]; then
        return 1
    fi

    HS_RETRIES_REMAINING=$(cat "${hs_dir}/retries_remaining" 2>/dev/null || echo "0")
    HS_RETRY_DELAY=$(cat "${hs_dir}/retry_delay" 2>/dev/null || echo "300")
    HS_FINGERPRINT=$(cat "${hs_dir}/fingerprint" 2>/dev/null || echo "")
    HS_INITIATED_AT=$(cat "${hs_dir}/initiated_at" 2>/dev/null || echo "")
    HS_NEXT_RETRY_AT=$(cat "${hs_dir}/next_retry_at" 2>/dev/null || echo "0")
    return 0
}

# Decrement retry counter and update next_retry_at
decrement_handshake_retry() {
    local peer="$1"
    local safe_peer="${peer//[^a-zA-Z0-9@._-]/_}"
    local hs_dir="${INTERCLAW_PENDING_HS_DIR}/${safe_peer}"

    [[ -d "$hs_dir" ]] || return 1

    local remaining
    remaining=$(cat "${hs_dir}/retries_remaining" 2>/dev/null || echo "0")
    remaining=$(( remaining - 1 ))
    echo "$remaining" > "${hs_dir}/retries_remaining"

    local delay
    delay=$(cat "${hs_dir}/retry_delay" 2>/dev/null || echo "300")
    local next_retry; next_retry=$(( $(date +%s) + delay ))
    echo "$next_retry" > "${hs_dir}/next_retry_at"

    log DEBUG "Handshake retry for ${peer}: ${remaining} remaining, next at $(date -d @"$next_retry" -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "$next_retry")"
}

# Remove a pending handshake (completed or exhausted)
remove_pending_handshake() {
    local peer="$1"
    local safe_peer="${peer//[^a-zA-Z0-9@._-]/_}"
    rm -rf "${INTERCLAW_PENDING_HS_DIR:?}/${safe_peer}"
    log INFO "Removed pending handshake for ${peer}"
}

# List all pending handshakes: outputs "peer|retries|next_retry_epoch|initiated"
list_pending_handshakes() {
    local hs_dir
    for hs_dir in "${INTERCLAW_PENDING_HS_DIR}"/*/; do
        [[ -d "$hs_dir" ]] || continue
        local peer; peer=$(basename "$hs_dir")
        local retries; retries=$(cat "${hs_dir}/retries_remaining" 2>/dev/null || echo "0")
        local next_retry; next_retry=$(cat "${hs_dir}/next_retry_at" 2>/dev/null || echo "0")
        local initiated; initiated=$(cat "${hs_dir}/initiated_at" 2>/dev/null || echo "")
        echo "${peer}|${retries}|${next_retry}|${initiated}"
    done
}

# ── Raw Email Parsing ─────────────────────────────────────────────
# Parses an RFC 822 raw email into headers and body.
# Sets: RAW_FROM, RAW_TO, RAW_SUBJECT, RAW_CONTENT_TYPE, RAW_X_AGENT_ID, RAW_BODY
parse_raw_email() {
    local input="$1"

    RAW_FROM=""
    RAW_TO=""
    RAW_SUBJECT=""
    RAW_CONTENT_TYPE=""
    RAW_X_AGENT_ID=""
    RAW_BODY=""

    local in_headers=true
    local current_header=""
    local current_value=""

    # Helper to commit the current header
    _commit_header() {
        case "${current_header,,}" in
            from)           RAW_FROM="$current_value" ;;
            to)             RAW_TO="$current_value" ;;
            subject)        RAW_SUBJECT="$current_value" ;;
            content-type)   RAW_CONTENT_TYPE="$current_value" ;;
            x-agent-id)     RAW_X_AGENT_ID="$current_value" ;;
        esac
        current_header=""
        current_value=""
    }

    local line
    while IFS= read -r line || [[ -n "$line" ]]; do
        if $in_headers; then
            # Blank line = end of headers
            if [[ -z "$line" ]] || [[ "$line" == $'\r' ]]; then
                _commit_header
                in_headers=false
                continue
            fi

            # Continuation line (starts with whitespace)
            if [[ "$line" =~ ^[[:space:]] ]]; then
                current_value="${current_value} ${line## }"
                continue
            fi

            # New header — commit previous
            if [[ -n "$current_header" ]]; then
                _commit_header
            fi

            # Parse Header: Value
            if [[ "$line" =~ ^([A-Za-z][A-Za-z0-9_-]*):(.*)$ ]]; then
                current_header="${BASH_REMATCH[1]}"
                current_value="${BASH_REMATCH[2]## }"
                # Strip trailing CR
                current_value="${current_value%$'\r'}"
            fi
        else
            # Body lines
            # Strip trailing CR (CRLF → LF)
            line="${line%$'\r'}"
            if [[ -z "$RAW_BODY" ]]; then
                RAW_BODY="$line"
            else
                RAW_BODY="${RAW_BODY}
${line}"
            fi
        fi
    done <<< "$input"

    # Commit any remaining header if we never hit a blank line
    if $in_headers && [[ -n "$current_header" ]]; then
        _commit_header
    fi

    # Extract bare email from "Display Name <email@host>" format
    if [[ "$RAW_FROM" =~ \<([^>]+)\> ]]; then
        RAW_FROM="${BASH_REMATCH[1]}"
    fi
    # Trim whitespace
    RAW_FROM="${RAW_FROM## }"
    RAW_FROM="${RAW_FROM%% }"

    # Handle multipart: extract text/plain part
    if [[ "${RAW_CONTENT_TYPE,,}" == *"multipart"* ]]; then
        local boundary=""
        # Try quoted boundary first (handles spaces), then unquoted
        if [[ "$RAW_CONTENT_TYPE" =~ boundary=\"([^\"]+)\" ]]; then
            boundary="${BASH_REMATCH[1]}"
        elif [[ "$RAW_CONTENT_TYPE" =~ boundary=([^\";[:space:]]+) ]]; then
            boundary="${BASH_REMATCH[1]}"
        fi
        if [[ -n "$boundary" ]]; then
            # Extract the first text/plain part
            local in_text_part=false
            local past_part_headers=false
            local text_body=""
            while IFS= read -r line; do
                if [[ "$line" == "--${boundary}"* ]]; then
                    if $in_text_part && $past_part_headers; then
                        break  # end of our text/plain part
                    fi
                    in_text_part=false
                    past_part_headers=false
                    continue
                fi
                if ! $in_text_part; then
                    if [[ "${line,,}" == *"content-type:"*"text/plain"* ]]; then
                        in_text_part=true
                    fi
                    continue
                fi
                if ! $past_part_headers; then
                    if [[ -z "$line" ]] || [[ "$line" == $'\r' ]]; then
                        past_part_headers=true
                    fi
                    continue
                fi
                if [[ -z "$text_body" ]]; then
                    text_body="$line"
                else
                    text_body="${text_body}
${line}"
                fi
            done <<< "$RAW_BODY"
            if [[ -n "$text_body" ]]; then
                RAW_BODY="$text_body"
            fi
        fi
    fi
}

# ── InterClaw Message Filter ─────────────────────────────────────
# Returns 0 if the raw email is an InterClaw message, 1 otherwise.
# Must be called AFTER parse_raw_email.
is_interclaw_message() {
    # Check 1: X-Agent-ID header present in the email
    if [[ -n "$RAW_X_AGENT_ID" ]]; then
        return 0
    fi

    # Check 2: Subject starts with a valid InterClaw tag
    local tag
    for tag in $VALID_TAGS; do
        if [[ "$RAW_SUBJECT" == "[$tag]"* ]]; then
            return 0
        fi
    done

    # Check 3: Body contains InterClaw protocol headers (PGP-wrapped)
    if echo "$RAW_BODY" | grep -q "^GlobalSeq:" 2>/dev/null; then
        return 0
    fi
    if echo "$RAW_BODY" | grep -q "X-Agent-ID:" 2>/dev/null; then
        return 0
    fi

    return 1
}
